// -------------------------------------------------------------- -*- C++ -*-
// File: ilodiet.cpp
// Version 22.1.0  
// --------------------------------------------------------------------------
// Licensed Materials - Property of IBM
// 5725-A06 5725-A29 5724-Y48 5724-Y49 5724-Y54 5724-Y55 5655-Y21
// Copyright IBM Corporation 2000, 2022. All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
// --------------------------------------------------------------------------
//
// Reads data for a dietary problem, builds the model, and solves it.
//
// Input data:
// foodMin[j]      minimum amount of food j to use
// foodMax[j]      maximum amount of food j to use 
// foodCost[j]     cost for one unit of food j
// nutrMin[i]      minimum amount of nutrient i
// nutrMax[i]      maximum amount of nutrient i
// nutrPer[i][j]   nutrition amount of nutrient i in food j
//
// Modeling variables:
// buy[j]          amount of food j to purchase
//
// Objective:
// minimize sum(j) buy[j] * foodCost[j]
//
// Constraints:
// forall foods i: nutrMin[i] <= sum(j) buy[j] * nutrPer[i][j] <= nutrMax[j]
//
// Options:
// - build the model by column, rather than by row
// - restrict to selecting integral food quantities
// - create a multi-objective model
//
// See the usage message for more details.

#include <sstream>
#include <ilcplex/ilocplex.h>
ILOSTLBEGIN


// Print a usage message to stderr and abort.
void usage(const char* name) {
   cerr << endl;
   cerr << "Usage: " << name << " [options...] <datafile>" << endl;
   cerr << "   By default, the problem will be generated by rows." << endl;
   cerr << endl;
   cerr << "   Supported options are:" << endl;
   cerr << "   -r    generate problem by row" << endl;
   cerr << "   -c    generate problem by column" << endl;
   cerr << "   -i    restrict to integral food quantities (i.e., convert to a MIP)" << endl;
   cerr << "   -m    create a multi-objective problem where, in addition to" << endl;
   cerr << "         minimizing cost, the number of unique foods selected is" << endl;
   cerr << "         maximized (can be combined with -i)" << endl;
   cerr << endl;
   exit(2);
}


void
buildModelByRow(IloModel           mod,
                IloNumVarArray     buy,
                IloObjective       cost,
                const IloNumArray  foodMin,
                const IloNumArray  foodMax,
                const IloNumArray  foodCost, 
                const IloNumArray  nutrMin,
                const IloNumArray  nutrMax,
                const IloNumArray2 nutrPer,
                IloNumVar::Type type) {
   IloEnv env = mod.getEnv();

   buy.clear();
   IloNumVarArray tmp(env, foodMin, foodMax, type);
   buy.add(tmp);
   tmp.end();

   IloInt n = foodCost.getSize();
   IloInt m = nutrMin.getSize();

   cost.setExpr(IloScalProd(buy, foodCost));
   cost.setSense(IloObjective::Minimize);

   for (IloInt i = 0; i < m; i++) {
      IloExpr expr(env);
      for (IloInt j = 0; j < n; j++) {
         expr += buy[j] * nutrPer[i][j];
      }
      mod.add(nutrMin[i] <= expr <= nutrMax[i]);
      expr.end();
   }
}


void
buildModelByColumn(IloModel           mod,
                   IloNumVarArray     buy,
                   IloObjective       cost,
                   const IloNumArray  foodMin,
                   const IloNumArray  foodMax,
                   const IloNumArray  foodCost, 
                   const IloNumArray  nutrMin,
                   const IloNumArray  nutrMax,
                   const IloNumArray2 nutrPer,
                   IloNumVar::Type    type) {
   IloEnv env = mod.getEnv();

   IloInt n = foodCost.getSize();
   IloInt m = nutrMin.getSize();

   IloRangeArray range (env, nutrMin, nutrMax);
   mod.add(range);
   cost.setSense(IloObjective::Minimize);

   for (IloInt j = 0; j < n; j++) {
      IloNumColumn col = cost(foodCost[j]);
      for (IloInt i = 0; i < m; i++) {
         col += range[i](nutrPer[i][j]);
      }
      buy.add(IloNumVar(col, foodMin[j], foodMax[j], type));
      col.end();
   }
   range.end();
}

void
createMultiObj(IloModel mod,
               IloNumVarArray buy,
               IloObjective cost,
               IloObjective variety) {
   IloEnv env = mod.getEnv();
   // Create binary variables for each food.
   IloNumVarArray varUsed(env, buy.getSize(), 0.0, 1.0, ILOBOOL);

   // Add indicator constraints that force the binary variables to 1 if
   // a food is purchased/used.
   for (IloInt i = 0; i < buy.getSize(); ++i) {
      mod.add(IloIfThen(env, varUsed[i] == 0, buy[i] == 0.0));
      mod.add(IloIfThen(env, buy[i] == 0.0, varUsed[i] == 0));
   }

   // Set up the second objective so that it maximizes the sum of the
   // binary variables.
   variety.setExpr(IloSum(varUsed));
   variety.setSense(IloObjective::Maximize);

   // Create an array of objectives:
   // - the first objective minimizes the cost
   // - the second objective maximizes the variety
   IloNumExprArray objArray(env);
   objArray.add(cost.getExpr());
   objArray.add(variety.getExpr());

   // Use a negative weight to maximize the second objective. The
   // objective senses of all objective functions must match. Hence, we
   // have to formulate max(sum) as min(-sum).
   IloNumArray weights (env, 2);
   weights[0] = 1.0;
   weights[1] = -1.0;

   // Adjust priorities such that we optimize the first objective
   // first (i.e., give it a higher priority).
   IloIntArray priorities (env, 2);
   priorities[0] = 2;
   priorities[1] = 1;

   // Allow a small degradation in the first objective.
   IloNumArray absTols (env, 2);
   absTols[0] = 0.5;
   absTols[1] = 0.0;

   IloNumArray relTols (env, 2);
   relTols[0] = 0.0;
   relTols[1] = 0.0;

   // Add the lexicographic objective to the model.
   mod.add(IloMinimize(env, IloStaticLex(env, objArray, weights,
                                         priorities, absTols, relTols)));
}

#define PRINT_ARG(c,w,i) c, w, #w, i

void
printSolutionStat(IloCplex cplex,
                  const char *what,
                  const char *val)
{
   cplex.out() << "    " << what << ": "
               << ((strlen(val) > 0) ? val : "---")
               << endl;
}


void
printMultiObjInfo(IloCplex cplex,
                  IloCplex::MultiObjIntInfo what,
                  const char *whatString,
                  int subprob)
{
   stringstream valString;
   try {
      valString << cplex.getMultiObjInfo(what, subprob);
   }
   catch (IloException &ignore) { }
   printSolutionStat(cplex, whatString, valString.str().c_str());
}


void
printMultiObjInfo(IloCplex cplex,
                  IloCplex::MultiObjInt64Info what,
                  const char *whatString,
                  int subprob)
{
   stringstream valString;
   try {
      valString << cplex.getMultiObjInfo(what, subprob);
   }
   catch (IloException &ignore) { }
   printSolutionStat(cplex, whatString, valString.str().c_str());
}


void
printMultiObjInfo(IloCplex cplex,
                  IloCplex::MultiObjNumInfo what,
                  const char *whatString,
                  int subprob)
{
   stringstream valString;
   try {
      valString << cplex.getMultiObjInfo(what, subprob);
   }
   catch (IloException &ignore) { }
   printSolutionStat(cplex, whatString, valString.str().c_str());
}


// Print information about each of the subproblems
// solved during multi-objective optimization.
void
printSolutionStats (IloCplex cplex)
{
   IloInt num = cplex.getMultiObjNsolves();

   for (IloInt i = 0; i < num; ++i) {
      IloInt prio = cplex.getMultiObjInfo (IloCplex::MultiObjPriority, i);
      cplex.out() << "subproblem " << i << " [priority " << prio << "]:" << endl;
      printMultiObjInfo(PRINT_ARG(cplex, IloCplex::MultiObjError, i));
      printMultiObjInfo(PRINT_ARG(cplex, IloCplex::MultiObjStatus, i));
      printMultiObjInfo(PRINT_ARG(cplex, IloCplex::MultiObjTime, i));
      printMultiObjInfo(PRINT_ARG(cplex, IloCplex::MultiObjDetTime, i));
      printMultiObjInfo(PRINT_ARG(cplex, IloCplex::MultiObjNiterations, i));
      printMultiObjInfo(PRINT_ARG(cplex, IloCplex::MultiObjObjValue, i));
      printMultiObjInfo(PRINT_ARG(cplex, IloCplex::MultiObjBestObjValue, i));
      printMultiObjInfo(PRINT_ARG(cplex, IloCplex::MultiObjNnodes, i));
      printMultiObjInfo(PRINT_ARG(cplex, IloCplex::MultiObjNnodesLeft, i));
   }
}


int
main(int argc, char **argv)
{
   IloEnv env;

   try {
      const char*     filename  = "../../../examples/data/diet.dat";
      IloBool         byColumn  = IloFalse;
      IloNumVar::Type varType   = ILOFLOAT;
      IloBool         multiobj  = IloFalse;

      for (IloInt i = 1; i < argc; i++) {
         if (argv[i][0] == '-') {
            if (strcmp(argv[i], "-r") == 0)
               byColumn = IloFalse;
            else if (strcmp(argv[i], "-c") == 0)
               byColumn = IloTrue;
            else if (strcmp(argv[i], "-i") == 0)
               varType = ILOINT;
            else if (strcmp(argv[i], "-m") == 0)
               multiobj = IloTrue;
            else {
               cerr << "Unknown argument: " << argv[i] << endl;
               usage(argv[0]);
            }
         }
         else {
            filename = argv[i];
         }
      }

      // Read the data.

      ifstream file(filename);
      if (!file) {
         cerr << "ERROR: could not open file '" << filename
              << "' for reading" << endl;
         usage(argv[0]);
      }

      IloNumArray  foodCost(env), foodMin(env), foodMax(env);
      IloNumArray  nutrMin(env), nutrMax(env);
      IloNumArray2 nutrPer(env);

      file >> foodCost >> foodMin >> foodMax;
      file >> nutrMin >> nutrMax;
      file >> nutrPer;

      const IloInt nFoods = foodCost.getSize();
      const IloInt nNutr  = nutrMin.getSize();

      if ( foodMin.getSize() != nFoods ||
           foodMax.getSize() != nFoods ||
           nutrPer.getSize() != nNutr  ||
           nutrMax.getSize() != nNutr    ) {
         cerr << "ERROR: Data file '" << filename
              << "' contains inconsistent data" << endl;
         throw (-1);
      }

      for (IloInt i = 0; i < nNutr; i++) {
         if (nutrPer[i].getSize() != nFoods) {
            cerr << "ERROR: Data file '" << argv[0]
                 << "' contains inconsistent data" << endl;
            throw (-1);
         }
      }

      // Build the model.

      IloModel       mod(env);
      IloNumVarArray buy(env);
      IloObjective cost(env);
      cost.setName("cost");

      if ( byColumn ) {
         buildModelByColumn(mod, buy, cost, foodMin, foodMax,
                            foodCost, nutrMin, nutrMax, nutrPer,
                            varType);
      }
      else {
         buildModelByRow(mod, buy, cost, foodMin, foodMax,
                         foodCost, nutrMin, nutrMax, nutrPer,
                         varType);
      }

      // Optionally, create a second objective.

      IloObjective variety(env);
      variety.setName("number of foods");

      if ( multiobj ) {
         createMultiObj(mod, buy, cost, variety);
      }
      else {
         mod.add(cost);
      }

      // Write a copy of the problem to a file.

      IloCplex cplex(mod);
      cplex.exportModel("ilodiet.lp");

      // Solve model

      if ( multiobj ) {
         // Set multi-objective display level to "detailed".
         cplex.setParam(IloCplex::Param::MultiObjective::Display, 2);

         // Purely for demonstrative purposes, set global and local limits
         // using parameter sets.

         // First, set the global deterministic time limit.
         cplex.setParam(IloCplex::Param::DetTimeLimit, 60000);

         // Second, create a parameter set for each priority.
         IloArray<IloCplex::ParameterSet> params(env, 2);
         params[0] = IloCplex::ParameterSet(env);
         params[1] = IloCplex::ParameterSet(env);

         // Set the local deterministic time limits. Optimization will stop
         // whenever either the global or local limit is exceeded.
         params[0].setParam(IloCplex::Param::DetTimeLimit, 50000);
         params[1].setParam(IloCplex::Param::DetTimeLimit, 25000);

         // Optimize the multi-objective problem and apply the parameter
         // sets that were created above. The parameter sets are used
         // one-by-one by each optimization.
         if ( !cplex.solve(params) )
            throw IloAlgorithm::Exception("Failed to optimize");
      }
      else {
         if ( !cplex.solve() )
            throw IloAlgorithm::Exception("Failed to optimize");
      }

      // Print the solution status.

      cplex.out() << endl;
      cplex.out() << "Solution status = " << cplex.getStatus() << endl;

      // Print the objective value(s).

      if ( multiobj ) {
         cplex.out() << "Solution value 0 (" << cost.getName()
                     << ") = " << cplex.getValue(cost.getExpr(), -1)
                     << endl;
         cplex.out() << "Solution value 1 (" << variety.getName()
                     << ") = " << cplex.getValue(variety.getExpr(), -1)
                     << endl;
         cplex.out() << endl;

         printSolutionStats (cplex);
      }
      else {
         cplex.out() << "Solution value = "
                     << cplex.getObjValue() << endl;
      }
      cplex.out() << endl;

      // Print the solution values.

      for (IloInt i = 0; i < foodCost.getSize(); i++) {
         cplex.out() << "Food " << i << ":  Buy = " << cplex.getValue(buy[i]) << endl;
      }
   }
   catch (IloException& ex) {
      cerr << "Concert exception caught" << endl;
      throw;
   }
   catch (...) {
      cerr << "Unknown exception caught" << endl;
      throw;
   }

   env.end();

   return 0;
}
