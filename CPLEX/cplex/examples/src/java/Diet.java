/* --------------------------------------------------------------------------
 * File: Diet.java   
 * Version 22.1.0  
 * --------------------------------------------------------------------------
 * Licensed Materials - Property of IBM
 * 5725-A06 5725-A29 5724-Y48 5724-Y49 5724-Y54 5724-Y55 5655-Y21
 * Copyright IBM Corporation 2001, 2022. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 * --------------------------------------------------------------------------
 *
 * Reads data for a dietary problem, builds the model, and solves it.
 *
 * Input data:
 * foodMin[j]          minimum amount of food j to use
 * foodMax[j]          maximum amount of food j to use 
 * foodCost[j]         cost for one unit of food j
 * nutrMin[i]          minimum amount of nutrient i
 * nutrMax[i]          maximum amount of nutrient i
 * nutrPerFood[i][j]   nutrition amount of nutrient i in food j
 *
 * Modeling variables:
 * buy[j]              amount of food j to purchase
 *
 * Objective:
 * minimize sum(j) buy[j] * foodCost[j]
 *
 * Constraints:
 * forall foods i: nutrMin[i] <= sum(j) buy[j] * nutrPer[i][j] <= nutrMax[j]
 *
 * Options:
 * - build the model by column, rather than by row
 * - restrict to selecting integral food quantities
 * - create a multi-objective model
 *
 * See the usage message for more details.
 */

import ilog.concert.*;
import ilog.cplex.*;
import ilog.cplex.IloCplex.MultiObjIntInfo;
import ilog.cplex.IloCplex.MultiObjLongInfo;
import ilog.cplex.IloCplex.MultiObjNumInfo;

public class Diet {

   /**
    *  Print a usage message to stderr and abort.
    */
   static void usage() {
      System.err.println();
      System.err.println("Usage: Diet [options...] <datafile>");
      System.err.println("   By default, the problem will be generated by rows.");
      System.err.println();
      System.err.println("   Supported options are:");
      System.err.println("   -r    generate problem by row");
      System.err.println("   -c    generate problem by column");
      System.err.println("   -i    restrict to integral food quantities (i.e., convert to a MIP)");
      System.err.println("   -m    create a multi-objective problem where, in addition to");
      System.err.println("         minimizing cost, the number of unique foods selected is");
      System.err.println("         maximized (can be combined with -i)");
      System.err.println();
      System.exit(2);
   }

   /**
    * A class to store problem data.
    */
   static class Data {
      int        nFoods;
      int        nNutrs;
      double[]   foodCost;
      double[]   foodMin;
      double[]   foodMax;
      double[]   nutrMin;
      double[]   nutrMax;
      double[][] nutrPerFood; 
    
      Data(String filename) throws IloException, java.io.IOException,
                                   InputDataReader.InputDataReaderException {
         InputDataReader reader = new InputDataReader(filename);
         try {
	     foodCost = reader.readDoubleArray();
	     foodMin  = reader.readDoubleArray();
	     foodMax  = reader.readDoubleArray();
	     nutrMin  = reader.readDoubleArray();
	     nutrMax  = reader.readDoubleArray();
	     nutrPerFood = reader.readDoubleArrayArray();
	     
	     nFoods = foodMax.length;
	     nNutrs = nutrMax.length;
	     
	     if ( nFoods != foodMin.length  ||
		  nFoods != foodMax.length    )
		 throw new IloException("inconsistent data in file " + filename);
	     if ( nNutrs != nutrMin.length    ||
		  nNutrs != nutrPerFood.length  )
		 throw new IloException("inconsistent data in file " + filename);
	     for (int i = 0; i < nNutrs; ++i) {
		 if ( nutrPerFood[i].length != nFoods )
		     throw new IloException("inconsistent data in file " + filename);
	     }
	 }
	 finally {
	     reader.close();
	 }
      }
   }
    
   static void buildModelByRow(IloModeler    model,
                               Data          data,
                               IloNumVar[]   buy,
                               IloObjective  cost,
                               IloNumVarType type) throws IloException {
      int nFoods = data.nFoods;
      int nNutrs = data.nNutrs;

      for (int j = 0; j < nFoods; j++) {
         buy[j] = model.numVar(data.foodMin[j], data.foodMax[j], type);
      }

      cost.setExpr(model.scalProd(data.foodCost, buy));

      for (int i = 0; i < nNutrs; i++) {
         model.addRange(data.nutrMin[i],
                        model.scalProd(data.nutrPerFood[i], buy),
                        data.nutrMax[i]);
      }
   }

   static void buildModelByColumn(IloMPModeler  model,
                                  Data          data,
                                  IloNumVar[]   buy,
                                  IloObjective  cost,
                                  IloNumVarType type) throws IloException {
      int nFoods = data.nFoods;
      int nNutrs = data.nNutrs;

      IloRange[]   constraint = new IloRange[nNutrs];

      for (int i = 0; i < nNutrs; i++) {
         constraint[i] = model.addRange(data.nutrMin[i], data.nutrMax[i]);
      }

      for (int j = 0; j < nFoods; j++) {
         IloColumn col = model.column(cost, data.foodCost[j]);
         for (int i = 0; i < nNutrs; i++) {
            col = col.and(model.column(constraint[i], data.nutrPerFood[i][j]));
         }
         buy[j] = model.numVar(col, data.foodMin[j], data.foodMax[j], type);
      }
   }

   static void createMultiObj(IloCplex cplex,
                              IloNumVar[] buy,
                              IloObjective cost,
                              IloObjective variety) throws IloException {
      // Create binary variables for each food.
      IloNumVar[] varUsed = cplex.numVarArray(buy.length, 0.0, 1.0,
                                              IloNumVarType.Bool);

      // Add indicator constraints that force the binary variables to 1 if
      // a food is purchased/used.
      for (int i = 0; i < buy.length; ++i) {
         cplex.add(cplex.ifThen(cplex.eq(varUsed[i], 0),
                                cplex.eq(buy[i], 0.0)));
         cplex.add(cplex.ifThen(cplex.eq(buy[i], 0.0),
                                cplex.eq(varUsed[i], 0)));
      }

      // Set up the second objective so that it maximizes the sum of the
      // binary variables.
      variety.setExpr(cplex.sum(varUsed));
      variety.setSense(IloObjectiveSense.Maximize);

      // Create an array of objectives:
      // - the first objective minimizes the cost
      // - the second objective maximizes the variety
      IloNumExpr[] objArray = new IloNumExpr[] {
         cost.getExpr(),
         variety.getExpr()
      };

      // Use a negative weight to maximize the second objective. The
      // objective senses of all objective functions must match. Hence, we
      // have to formulate max(sum) as min(-sum).
      double[] weights = new double[] { 1.0, -1.0 };

      // Adjust priorities such that we optimize the first objective
      // first (i.e., give it a higher priority).
      int[] priorities = new int[] { 2, 1 };

      // Allow a small degradation in the first objective.
      double[] absTols = new double[] { 0.5, 0.0 };
      double[] relTols = new double[] { 0.0, 0.0 };

      // Add the lexicographic objective to the model.
      cplex.add(cplex.minimize(cplex.staticLex(objArray, weights,
                                               priorities, absTols,
                                               relTols, "staticLex1")));
   }

   static void printSolutionStat(String what, String val) {
      System.out.printf("    %s: %s%n", what,
                        (val != null) ? val : "---");
   }

   static void printMultiObjInfo(IloCplex cplex,
                                 MultiObjIntInfo what,
                                 int subprob)
         throws IloException {
      String valString = null;
      try {
         valString = Integer.toString(cplex.getMultiObjInfo(what, subprob));
      }
      catch (IloException ignore) { }
      printSolutionStat(what.toString(), valString);
   }

   static void printMultiObjInfo(IloCplex cplex,
                                 MultiObjLongInfo what,
                                 int subprob)
         throws IloException {
      String valString = null;
      try {
         valString = Long.toString(cplex.getMultiObjInfo(what, subprob));
      }
      catch (IloException ignore) { }
      printSolutionStat(what.toString(), valString);
   }

   static void printMultiObjInfo(IloCplex cplex,
                                 MultiObjNumInfo what,
                                 int subprob)
         throws IloException {
      String valString = null;
      try {
         valString = Double.toString(cplex.getMultiObjInfo(what, subprob));
      }
      catch (IloException ignore) { }
      printSolutionStat(what.toString(), valString);
   }

   static void printSolutionStats (IloCplex cplex) throws IloException {
      final int num = cplex.getMultiObjNsolves();

      for (int i = 0; i < num; ++i) {
         int prio = cplex.getMultiObjInfo(
            MultiObjIntInfo.MultiObjPriority, i);
         System.out.printf("subproblem %d [priority %d]:%n", i, prio);
         printMultiObjInfo(cplex, MultiObjIntInfo.MultiObjError, i);
         printMultiObjInfo(cplex, MultiObjIntInfo.MultiObjStatus, i);
         printMultiObjInfo(cplex, MultiObjNumInfo.MultiObjTime, i);
         printMultiObjInfo(cplex, MultiObjNumInfo.MultiObjDetTime, i);
         printMultiObjInfo(cplex, MultiObjLongInfo.MultiObjNiterations, i);
         printMultiObjInfo(cplex, MultiObjNumInfo.MultiObjObjValue, i);
         printMultiObjInfo(cplex, MultiObjNumInfo.MultiObjBestObjValue, i);
         printMultiObjInfo(cplex, MultiObjLongInfo.MultiObjNnodes, i);
         printMultiObjInfo(cplex, MultiObjLongInfo.MultiObjNnodesLeft, i);
      }
   }

   public static void main(String[] args) throws Exception {
      // Set default arguments and parse command line.
      String filename = "../../../examples/data/diet.dat";
      boolean byColumn = false;
      IloNumVarType varType = IloNumVarType.Float;
      boolean multiobj = false;

      for (int i = 0; i < args.length; i++) {
         if ( args[i].charAt(0) == '-') {
            if (args[i].equals("-r"))
               byColumn = false;
            else if (args[i].equals("-c"))
               byColumn = true;
            else if (args[i].equals("-i"))
               varType = IloNumVarType.Int;
            else if (args[i].equals("-m"))
               multiobj = true;
            else {
               System.err.printf("Unknown argument: %s%n", args[i]);
               usage();
            }
         }
         else {
            filename = args[i];
         }
      }

      // Read the data.

      Data data = new Data(filename);
      final int nFoods = data.nFoods;
      IloCplex cplex = new IloCplex();
      try {
         // Build model
         IloNumVar[] buy = new IloNumVar[nFoods];
         IloObjective cost = cplex.minimize();
         cost.setName("cost");

         if ( byColumn )
            buildModelByColumn(cplex, data, buy, cost, varType);
         else
            buildModelByRow(cplex, data, buy, cost, varType);

         // Optionally, create a second objective.

         IloObjective variety = cplex.maximize();
         variety.setName("number of foods");
         if ( multiobj ) {
            createMultiObj(cplex, buy, cost, variety);
         }
         else {
            cplex.add(cost);
         }

         // Write a copy of the problem to a file.

         cplex.exportModel("Diet.java.lp");

         // Solve model

         if ( multiobj ) {
            // Set multi-objective display level to "detailed".
            cplex.setParam(IloCplex.Param.MultiObjective.Display, 2);

            // Purely for demonstrative purposes, set global and local limits
            // using parameter sets.

            // First, set the global deterministic time limit.
            cplex.setParam(IloCplex.Param.DetTimeLimit, 60000);

            // Second, create a parameter set for each priority.
            IloCplex.ParameterSet[] params = new IloCplex.ParameterSet[2];
            params[0] = new IloCplex.ParameterSet();
            params[1] = new IloCplex.ParameterSet();

            // Set the local deterministic time limits. Optimization will stop
            // whenever either the global or local limit is exceeded.
            params[0].setParam(IloCplex.Param.DetTimeLimit, 50000);
            params[1].setParam(IloCplex.Param.DetTimeLimit, 25000);

            // Optimize the multi-objective problem and apply the parameter
            // sets that were created above. The parameter sets are used
            // one-by-one by each optimization.
            if ( !cplex.solve(params) )
               throw new IloException("Failed to optimize");
         }
         else {
            if ( !cplex.solve() )
               throw new IloException("Failed to optimize");
         }

         // Print the solution status.

         System.out.println();
         System.out.println("Solution status = " + cplex.getStatus());

         // Print the objective value(s).

         if ( multiobj ) {
            System.out.printf("Solution value 0 (%s) = %f%n",
                              cost.getName(),
                              cplex.getValue(cost.getExpr(), -1));
            System.out.printf("Solution value 1 (%s) = %f%n",
                              variety.getName(),
                              cplex.getValue(variety.getExpr(), -1));
            System.out.println();

            printSolutionStats(cplex);
         }
         else {
            System.out.printf("Solution value = %f%n", cplex.getObjValue());
         }
         System.out.println();

         // Print the solution values.

         for (int i = 0; i < nFoods; i++) {
            System.out.printf("Food %d: Buy = %f%n", i, cplex.getValue(buy[i]));
         }

      }
      finally {
         cplex.end();
      }
   }

}

