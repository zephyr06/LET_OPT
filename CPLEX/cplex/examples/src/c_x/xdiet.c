/* --------------------------------------------------------------------------
 * File: xdiet.c
 * Version 22.1.0
 * --------------------------------------------------------------------------
 * Licensed Materials - Property of IBM
 * 5725-A06 5725-A29 5724-Y48 5724-Y49 5724-Y54 5724-Y55 5655-Y21
 * Copyright IBM Corporation 1997, 2022. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 * --------------------------------------------------------------------------
 */

/* Reads data for a dietary problem, builds the model, and solves it.
 *
 * Input data:
 * foodmin[j]          minimum amount of food j to use
 * foodmax[j]          maximum amount of food j to use
 * cost[j]             cost for one unit of food j
 * nutrmin[i]          minimum amount of nutrient i
 * nutrmax[i]          maximum amount of nutrient i
 * nutrPer[i][j]       nutrition amount of nutrient i in food j
 *
 * Modeling variables:
 * buy[j]              amount of food j to purchase
 *
 * Objective:
 * minimize sum(j) buy[j] * cost[j]
 *
 * Constraints:
 * forall foods i: nutrmin[i] <= sum(j) buy[j] * nutrper[i][j] <= nutrmax[j]
 *
 * Options:
 * - build the model by column, rather than by row
 * - restrict to selecting integral food quantities
 * - create a multi-objective model
 *
 * See the usage message for more details.
 */

/* Bring in the CPLEX function declarations and the C library 
   header file stdio.h with the following single include. */

#include <ilcplex/cplexx.h>

/* Bring in the declarations for the string functions */

#include <stdlib.h>
#include <string.h>

#define TRUE       1
#define FALSE      0

/* Data structures for printing multi-objective solution information. */

struct multiobjinfo {
   int type;
   int what;
   char const *name;
};
typedef struct multiobjinfo MULTIOBJINFO, *MULTIOBJINFOptr;

enum multiobjinfotype {
   INT_TYPE,
   CPXCNT_TYPE,
   DOUBLE_TYPE
};
typedef enum multiobjinfotype MULTIOBJINFOTYPE;

#define ROW(info_type,what) { info_type, what, #what }

static MULTIOBJINFO multiobjstats[] = {
   ROW (INT_TYPE, CPX_MULTIOBJ_ERROR),
   ROW (INT_TYPE, CPX_MULTIOBJ_STATUS),
   ROW (DOUBLE_TYPE, CPX_MULTIOBJ_TIME),
   ROW (DOUBLE_TYPE, CPX_MULTIOBJ_DETTIME),
   ROW (CPXCNT_TYPE, CPX_MULTIOBJ_ITCNT),
   ROW (DOUBLE_TYPE, CPX_MULTIOBJ_OBJVAL),
   ROW (DOUBLE_TYPE, CPX_MULTIOBJ_BESTOBJVAL),
   ROW (CPXCNT_TYPE, CPX_MULTIOBJ_NODECNT),
   ROW (CPXCNT_TYPE, CPX_MULTIOBJ_NODELEFTCNT),
};

union multiobjval {
   int i;
   CPXCNT l;
   double d;
};
typedef union multiobjval MULTIOBJVAL;

/* Forward declarations. */

static int
   readarray         (FILE *in, CPXDIM *num_p, double **data_p),
   readdata          (char const *file,
                      CPXDIM *nfoods_p, double **cost_p,
                      double **foodmin_p, double **foodmax_p,
                      CPXDIM *nnutr_p, double **nutrmin_p, double **nutrmax_p,
                      double ***nutrper_p),
   populatebyrow     (CPXENVptr env, CPXLPptr lp,
                      CPXDIM nfoods, double *cost,
                      double *foodmin, double *foodmax,
                      CPXDIM nnutr, double *nutrmin, double *nutrmax,
                      double **nutrper),
   populatebycolumn  (CPXENVptr env, CPXLPptr lp,
                      CPXDIM nfoods, double *cost,
                      double *foodmin, double *foodmax,
                      CPXDIM nnutr, double *nutrmin, double *nutrmax,
                      double **nutrper),
   useintvars        (CPXENVptr env, CPXLPptr lp, CPXDIM nfoods),
   usemultiobj       (CPXENVptr env, CPXLPptr lp, CPXDIM nfoods),
   printsolstats     (CPXENVptr env, CPXLPptr lp);

static void
   free_and_null     (char **ptr),
   usage             (char *progname);


/* Print a usage message to stderr and abort. */
static void
usage (char *progname)
{
   fprintf (stderr,
"Usage: %s [options...] <datafile>\n"
"   By default, the problem will be generated by rows.\n"
"\n"
"   Supported options are:\n"
"   -r    generate problem by row\n"
"   -c    generate problem by column\n"
"   -i    restrict to integral food quantities (i.e., convert to a MIP)\n"
"   -m    create a multi-objective problem where, in addition to\n"
"         minimizing cost, the number of unique foods selected is\n"
"         maximized (can be combined with -i)\n\n",
            progname);
   exit (2);
} /* END usage */


int
main (int argc, char **argv)
{
   int status = 0;

   CPXDIM nfoods = 0;
   CPXDIM nnutr  = 0;
   double *cost     = NULL;
   double *foodmin  = NULL;
   double *foodmax  = NULL;
   double *nutrmin  = NULL;
   double *nutrmax  = NULL;
   double **nutrper = NULL;

   double *buy = NULL;
   double objval;
   int    solstat;

   /* Declare and allocate space for the variables and arrays where we
      will store the optimization results including the status, objective
      value, variable values, dual values, row slacks and variable
      reduced costs. */

   CPXENVptr     env = NULL;
   CPXLPptr      lp = NULL;
   CPXPARAMSETptr ps[2] = {NULL, NULL};
   CPXDIM        i, j;

   char const *filename = "../../../examples/data/diet.dat";
   int bycolumn = FALSE;
   int intvars  = FALSE;
   int multiobj = FALSE;

   /* Check the command line arguments */

   for (i = 1; i < argc - 1; ++i) {
      if (argv[i][0] == '-') {
         if ( strcmp (argv[i], "-r") == 0 )
            bycolumn = FALSE;
         else if ( strcmp (argv[i], "-c") == 0 )
            bycolumn = TRUE;
         else if ( strcmp (argv[i], "-i") == 0 )
            intvars = TRUE;
         else if ( strcmp (argv[i], "-m") == 0 )
            multiobj = TRUE;
         else {
            fprintf (stderr, "Unknown argument %s\n", argv[i]);
            usage (argv[0]);
         }
      }
      else {
         filename = argv[i];
      }
   }

   /* Read the data. */

   status = readdata (filename, &nfoods, &cost, &foodmin, &foodmax,
                      &nnutr, &nutrmin, &nutrmax, &nutrper);
   if ( status ) {
      fprintf (stderr, "Failed to read file '%s'.\n", filename);
      goto TERMINATE;
   }

   /* Initialize the CPLEX environment */

   env = CPXXopenCPLEX (&status);

   /* If an error occurs, the status value indicates the reason for
      failure.  A call to CPXXgeterrorstring will produce the text of
      the error message.  Note that CPXXopenCPLEX produces no output,
      so the only way to see the cause of the error is to use
      CPXXgeterrorstring.  For other CPLEX routines, the errors will
      be seen if the CPXPARAM_ScreenOutput indicator is set to CPX_ON.  */

   if ( env == NULL ) {
      char  errmsg[CPXMESSAGEBUFSIZE];
      fprintf (stderr, "Could not open CPLEX environment.\n");
      CPXXgeterrorstring (env, status, errmsg);
      fprintf (stderr, "%s", errmsg);
      goto TERMINATE;
   }

   /* Turn on output to the screen */

   status = CPXXsetintparam (env, CPXPARAM_ScreenOutput, CPX_ON);
   if ( status ) {
      fprintf (stderr, 
               "Failure to turn on screen indicator, error %d.\n", status);
      goto TERMINATE;
   }

   /* Turn on data checking */

   status = CPXXsetintparam (env, CPXPARAM_Read_DataCheck,
			     CPX_DATACHECK_WARN);
   if ( status ) {
      fprintf (stderr, 
               "Failure to turn on data checking, error %d.\n", status);
      goto TERMINATE;
   }

   /* Create the problem. */

   lp = CPXXcreateprob (env, &status, "diet");

   /* A returned pointer of NULL may mean that not enough memory
      was available or there was some other problem.  In the case of 
      failure, an error message will have been written to the error 
      channel from inside CPLEX.  In this example, the setting of
      the parameter CPXPARAM_ScreenOutput causes the error message to
      appear on stdout.  */

   if ( lp == NULL ) {
      fprintf (stderr, "Failed to create LP.\n");
      goto TERMINATE;
   }

   /* Set the objective name. */

   status = CPXXcopyobjname (env, lp, "cost");
   if ( status ) {
      fprintf (stderr,
               "Failure to set objective name, error %d.\n", status);
      goto TERMINATE;
   }

   /* Now populate the problem with the data.  For building large
      problems, consider setting the row, column and nonzero growth
      parameters before performing this task. */

   if ( bycolumn ) {
      status = populatebycolumn (env, lp, nfoods, cost, foodmin, foodmax,
                                 nnutr, nutrmin, nutrmax, nutrper);
   }
   else {
      status = populatebyrow (env, lp, nfoods, cost, foodmin, foodmax,
                              nnutr, nutrmin, nutrmax, nutrper);
   }

   if ( status ) {
      fprintf (stderr, "Failed to populate problem.\n");
      goto TERMINATE;
   }

   /* Optionally, restrict the decision variables to take integral
      values. */

   if ( intvars ) {
      status = useintvars (env, lp, nfoods);
      if ( status ) {
         fprintf (stderr, "Failed to set integer variables.\n");
         goto TERMINATE;
      }
   }

   /* Optionally, create a second objective. */

   if ( multiobj ) {
      status = usemultiobj (env, lp, nfoods);
      if ( status ) {
         fprintf (stderr, "Failed to create second objective.\n");
         goto TERMINATE;
      }
   }

   /* Write a copy of the problem to a file. */

   status = CPXXwriteprob (env, lp, "xdiet.lp", NULL);
   if ( status ) {
      fprintf (stderr, "Failed to write LP to disk.\n");
      goto TERMINATE;
   }

   /* Optimize the problem and obtain solution. */

   if ( multiobj ) {
      /* Set multi-objective display level to "detailed". */
      status = CPXXsetintparam (env, CPXPARAM_MultiObjective_Display, 2);
      if ( status ) {
         fprintf (stderr,
                  "Failure to set multi-objective display, error %d.\n",
                  status);
         goto TERMINATE;
      }

      /* Purely for demonstrative purposes, set global and local limits
       * using parameter sets. Create a parameter set for each priority. */
      for (i = 0; i < 2; ++i) {
         ps[i] = CPXXparamsetcreate (env, &status);
         if ( ps[i] == NULL || status ) {
            fprintf (stderr, "Failed to create paramset.\n");
            goto TERMINATE;
         }
      }

      /* First, set the global deterministic time limit. */
      status = CPXXsetdblparam (env, CPXPARAM_DetTimeLimit, 60000.0);
      if ( status ) {
         fprintf (stderr, "Failed to set global parameter.\n");
         goto TERMINATE;
      }

      /* Second, set the local deterministic time limits. Optimization
       * will stop whenever either the global or local limit is exceeded. */
      status = CPXXparamsetadddbl (env, ps[0], CPXPARAM_DetTimeLimit, 50000.0);
      if ( status ) {
         fprintf (stderr, "Failed to add parameter.\n");
         goto TERMINATE;
      }

      status = CPXXparamsetadddbl (env, ps[1], CPXPARAM_DetTimeLimit, 25000.0);
      if ( status ) {
         fprintf (stderr, "Failed to add parameter.\n");
         goto TERMINATE;
      }

      /* Optimize the multi-objective problem and apply the parameter
       * sets that were created above. The parameter sets are used
       * one-by-one by each optimization. */
      status = CPXXmultiobjopt (env, lp, (CPXCPARAMSETptr *)(&ps[0]));
   }
   else if ( intvars )
      status = CPXXmipopt (env, lp);
   else
      status = CPXXlpopt (env, lp);

   if ( status ) {
      fprintf (stderr, "Failed to optimize.\n");
      goto TERMINATE;
   }

   /* Get the solution. */

   buy = malloc (CPXXgetnumcols (env, lp) * sizeof(*buy));
   if ( buy == NULL ) {
      status = CPXERR_NO_MEMORY;
      fprintf (stderr, "Could not allocate memory for solution.\n");
      goto TERMINATE;
   }

   status = CPXXsolution (env, lp, &solstat, &objval, buy, NULL, NULL, NULL);
   if ( status ) {
      fprintf (stderr, "Failed to obtain solution.\n");
      goto TERMINATE;
   }

   /* Write the output to the screen. */
   /* Print the solution status. */

   printf ("\nSolution status = %d\n", solstat);

   /* Print the objective value(s). */

   if ( multiobj ) {
      for (i = 0; i < CPXXgetnumobjs (env, lp); ++i) {
         double obj;
         char objname[256];
         CPXSIZE surplus;

         status = CPXXmultiobjgetobjval (env, lp, i, &obj);
         if ( status )  {
            fprintf (stderr, "Failed to obtain multiobj solution.\n");
            goto TERMINATE;
         }

         status = CPXXmultiobjgetname (env, lp, i, objname, 256, &surplus);
         if ( status ) {
            fprintf (stderr, "Failed to get objective name (%d).\n", status);
            goto TERMINATE;
         }

         printf ("Solution value %d (%s) = %f\n", i + 1, objname, obj);
      }
      printf ("\n");

      printsolstats (env, lp);
      if ( status ) {
         fprintf (stderr, "Failed to print multi-objective statistics.\n");
         goto TERMINATE;
      }
      printf ("\n");
   }
   else
      printf ("Solution value  = %f\n\n", objval);

   /* Print the solution values. */

   for (j = 0; j < nfoods; j++) {
      printf ("Food %d:  Buy = %10f\n", j, buy[j]);
   }

   
TERMINATE:

   /* Free up the problem as allocated by CPXXcreateprob, if necessary */

   if ( lp != NULL ) {
      status = CPXXfreeprob (env, &lp);
      if ( status ) {
         fprintf (stderr, "CPXXfreeprob failed, error code %d.\n", status);
      }
   }

   /* Free up the paramset, if necessary. */

   for (i = 0; i < 2; ++i) {
      if ( ps[i] != NULL ) {
         status = CPXXparamsetfree (env, &ps[i]);
         if ( status ) {
            fprintf (stderr, "Failed to free paramset.\n");
         }
      }
   }

   /* Free up the CPLEX environment, if necessary */

   if ( env != NULL ) {
      status = CPXXcloseCPLEX (&env);

      /* Note that CPXXcloseCPLEX produces no output,
         so the only way to see the cause of the error is to use
         CPXXgeterrorstring.  For other CPLEX routines, the errors will
         be seen if the CPXPARAM_ScreenOutput indicator is set to CPX_ON. */

      if ( status > 0 ) {
         char  errmsg[CPXMESSAGEBUFSIZE];
         fprintf (stderr, "Could not close CPLEX environment.\n");
         CPXXgeterrorstring (env, status, errmsg);
         fprintf (stderr, "%s", errmsg);
      }
   }

   if ( nutrper != NULL ) {
      for (i = 0; i < nnutr; ++i) {
         free_and_null ((char **) &(nutrper[i]));
      }
   }
   free_and_null ((char **) &nutrper);
   free_and_null ((char **) &cost);
   free_and_null ((char **) &foodmin);
   free_and_null ((char **) &foodmax);
   free_and_null ((char **) &nutrmin);
   free_and_null ((char **) &nutrmax);
   free_and_null ((char **) &buy);

   return (status);

}  /* END main */


static int
populatebyrow (CPXENVptr env, CPXLPptr lp,
               CPXDIM nfoods, double *cost, double *foodmin, double *foodmax,
               CPXDIM nnutr, double *nutrmin, double *nutrmax,
               double **nutrper)
{
   int status = 0;

   CPXNNZ zero = 0;
   CPXDIM *ind = NULL;
   CPXDIM i, j;

   ind = malloc(nfoods * sizeof(*ind));
   if ( ind == NULL ) {
      status = CPXERR_NO_MEMORY;
      goto TERMINATE;
   }
   for (j = 0; j < nfoods; j++) {
      ind[j] = j;
   }

   status = CPXXnewcols (env, lp, nfoods, cost, foodmin, foodmax, NULL, NULL);
   if ( status )  goto TERMINATE;

   for (i = 0; i < nnutr; i++) {
      double rng  = nutrmax[i] - nutrmin[i];

      status = CPXXaddrows (env, lp, 0, 1, nfoods, nutrmin+i, "R",
                           &zero, ind, nutrper[i], NULL, NULL);
      if ( status )  goto TERMINATE;

      status = CPXXchgrngval (env, lp, 1, &i, &rng);
      if ( status )  goto TERMINATE;
   }

TERMINATE:

   free_and_null ((char **)&ind);

   return (status);

}  /* END populatebyrow */



/* To populate by column, we first create the rows, and then add the
   columns.  */

static int
populatebycolumn (CPXENVptr env, CPXLPptr lp,
                  CPXDIM nfoods, double *cost, double *foodmin, double *foodmax,
                  CPXDIM nnutr, double *nutrmin, double *nutrmax,
                  double **nutrper)
{
   int status = 0;

   CPXDIM i, j;

   CPXNNZ zero    = 0;
   CPXDIM *ind    = NULL;
   double *val    = NULL;
   char   *sense  = NULL;
   double *rngval = NULL;

   sense = malloc(nnutr * sizeof(*sense));
   if ( sense == NULL ) {
      status = CPXERR_NO_MEMORY;
      goto TERMINATE;
   }
   for (i = 0; i < nnutr; i++) {
      sense[i] = 'R';
   }

   val = malloc(nnutr * sizeof(*val));
   if ( val == NULL ) {
      status = CPXERR_NO_MEMORY;
      goto TERMINATE;
   }

   rngval = malloc(nnutr * sizeof(*rngval));
   if ( rngval == NULL ) {
      status = CPXERR_NO_MEMORY;
      goto TERMINATE;
   }
   for (i = 0; i < nnutr; i++) {
      rngval[i] = nutrmax[i] - nutrmin[i];
   }

   ind = malloc(nfoods * sizeof(*ind));
   if ( ind == NULL ) {
      status = CPXERR_NO_MEMORY;
      goto TERMINATE;
   }
   for (i = 0; i < nnutr; i++) {
      ind[i] = i;
   }

   status = CPXXnewrows (env, lp, nnutr, nutrmin, sense, rngval, NULL);
   if ( status )  goto TERMINATE;

   for (j = 0; j < nfoods; ++j) {
      for (i = 0; i < nnutr; i++) {
         val[i] = nutrper[i][j];
      }

      status = CPXXaddcols (env, lp, 1, nnutr, cost+j, &zero,
                           ind, val, foodmin+j, foodmax+j, NULL);
      if ( status )  goto TERMINATE;
   }

TERMINATE:

   free_and_null ((char **)&sense);
   free_and_null ((char **)&rngval);
   free_and_null ((char **)&ind);
   free_and_null ((char **)&val);

   return (status);

}  /* END populatebycolumn */


/* This simple routine frees up the pointer *ptr, and sets *ptr to NULL */

static void
free_and_null (char **ptr)
{
   if ( *ptr != NULL ) {
      free (*ptr);
      *ptr = NULL;
   }
} /* END free_and_null */  


static int
readarray (FILE *in, CPXDIM *num_p, double **data_p)
{
   int    status = 0;
   CPXDIM max, num;
   char   ch;

   num = 0;
   max = 10;

   *data_p = malloc(max * sizeof(**data_p));
   if ( *data_p == NULL ) {
      status = CPXERR_NO_MEMORY;
      goto TERMINATE;
   }

   for (;;) {
      int read = fscanf (in, "%c", &ch);
      if ( read == 0 ) {
         status = -1;
         goto TERMINATE;
      }
      if ( ch == '\t' ||
           ch == '\r' ||
           ch == ' '  ||
           ch == '\n'   ) continue;
      if ( ch == '[' ) break;
      status = -1;
      goto TERMINATE;
   }

   for(;;) {
      int read = fscanf (in, "%lg", (*data_p)+num);
      if ( read == 0 ) {
         status = -1;
         goto TERMINATE;
      }
      num++;
      if ( num >= max ) {
         max *= 2;
         *data_p = realloc(*data_p, max * sizeof(**data_p));
         if ( *data_p == NULL ) {
            status = CPXERR_NO_MEMORY;
            goto TERMINATE;
         }
      }
      do {
         read = fscanf (in, "%c", &ch);
         if ( read == 0 ) {
            status = -1;
            goto TERMINATE;
         }
      } while (ch == ' ' || ch == '\n' || ch == '\t'  || ch == '\r');
      if ( ch == ']' ) break;
      else if ( ch != ',' ) {
         status = -1;
         goto TERMINATE;
      }
   }

   *num_p = num;

TERMINATE:

   return (status);

} /* END readarray */


static int
readdata (char const *file,
          CPXDIM *nfoods_p, double **cost_p,
          double **foodmin_p, double **foodmax_p,
          CPXDIM *nnutr_p, double **nutrmin_p, double **nutrmax_p,
          double ***nutrper_p)
{
   int status = 0;

   CPXDIM ncost, nfoodmin, nfoodmax;
   CPXDIM nmin, nmax;

   CPXDIM i, n;
   char ch;
   FILE *in = NULL;

   in = fopen(file, "r");
   if ( in == NULL ) {
      status = -1;
      goto TERMINATE;
   }

   if ( (status = readarray(in, &ncost, cost_p)) ) goto TERMINATE;
   if ( (status = readarray(in, &nfoodmin, foodmin_p)) ) goto TERMINATE;
   if ( (status = readarray(in, &nfoodmax, foodmax_p)) ) goto TERMINATE;
   if ( ncost != nfoodmin || ncost != nfoodmax ) {
      status = -1;
      goto TERMINATE;
   }
   *nfoods_p = ncost;

   if ( (status = readarray(in, &nmin, nutrmin_p)) ) goto TERMINATE;
   if ( (status = readarray(in, &nmax, nutrmax_p)) ) goto TERMINATE;
   if ( nmax != nmin ) {
      status = -1;
      goto TERMINATE;
   }
   *nnutr_p = nmin;

   *nutrper_p = malloc(nmin * sizeof(**nutrper_p));
   if ( *nutrper_p == NULL ) {
      status = CPXERR_NO_MEMORY;
      goto TERMINATE;
   }

   for (;;) {
      int read = fscanf (in, "%c", &ch);
      if ( read == 0 ) {
         status = -1;
         goto TERMINATE;
      }
      if ( ch == '\t' ||
           ch == '\r' ||
           ch == ' '  ||
           ch == '\n'   ) continue;
      if ( ch == '[' ) break;
      status = -1;
      goto TERMINATE;
   }
   for ( i = 0; i < nmin; i++ ) {
      int read;
      if ( (status = readarray(in, &n, (*nutrper_p)+i)) ) goto TERMINATE;
      if ( n != ncost ) {
         status = -1;
         goto TERMINATE;
      }
      read = fscanf (in, "%c", &ch);
      if ( read == 0 || (i < nmin-1  &&  ch != ',') ) {
         status = -1;
         goto TERMINATE;
      }
   }
   if ( ch != ']' ) {
      status = -1;
      goto TERMINATE;
   }


TERMINATE:
   if ( in != NULL )
      fclose (in);

   return (status);

} /* END readdata */


/* Require that foods are purchased/used in integral quantities.
 *
 * This will convert the model into a MIP.
 */
static int
useintvars (CPXENVptr env, CPXLPptr lp, CPXDIM nfoods)
{
   int status = 0;
   CPXDIM *ind = NULL;
   char *xctype = NULL;
   CPXDIM i;

   ind = malloc (nfoods * sizeof (*ind));
   xctype = malloc (nfoods * sizeof (*xctype));
   if ( ind == NULL || xctype == NULL ) {
      status = CPXERR_NO_MEMORY;
      goto TERMINATE;
   }

   for (i = 0; i < nfoods; ++i) {
      ind[i] = i;
      xctype[i] = CPX_INTEGER;
   }

   status = CPXXchgctype (env, lp, nfoods, ind, xctype);
   if ( status )  goto TERMINATE;

 TERMINATE:

   free_and_null ((char **)&ind);
   free_and_null ((char **)&xctype);

   return (status);

} /* END useintvars */


/* Add another objective to maximize the number of foods selected.
 *
 * This should improve the variety in the diet.
 */
static int
usemultiobj (CPXENVptr env, CPXLPptr lp, CPXDIM nfoods)
{
   int status = 0;
   double *lb = NULL;
   double *ub = NULL;
   char *xctype = NULL;
   CPXDIM i;
   CPXDIM const nbefore = CPXXgetnumcols (env, lp);
   CPXDIM *indtype = NULL;
   CPXDIM *indvar = NULL;
   int *complemented = NULL;
   double *rhs = NULL;
   char *sense = NULL;
   CPXNNZ *linbeg = NULL;
   CPXDIM *linind = NULL;
   double *linval = NULL;

   lb = malloc (nfoods * sizeof (*lb));
   ub = malloc (nfoods * sizeof (*ub));
   xctype = malloc (nfoods * sizeof (*xctype));
   if ( lb == NULL || ub == NULL || xctype == NULL ) {
      status = CPXERR_NO_MEMORY;
      goto TERMINATE;
   }

   for (i = 0; i < nfoods; ++i) {
      lb[i] = 0.0;
      ub[i] = 1.0;
      xctype[i] = CPX_BINARY;
   }

   /* Create binary variables for each food. */
   status = CPXXnewcols (env, lp, nfoods, NULL, lb, ub, xctype, NULL);
   if ( status )  goto TERMINATE;

   indtype = malloc (nfoods * sizeof (*indtype));
   indvar = malloc (nfoods * sizeof (*indvar));
   complemented = malloc (nfoods * sizeof (*complemented));
   rhs = malloc (nfoods * sizeof (*rhs));
   sense = malloc (nfoods * sizeof (*sense));
   linbeg = malloc (nfoods * sizeof (*linbeg));
   linind = malloc (nfoods * sizeof (*linind));
   linval = malloc (nfoods * sizeof (*linval));
   if ( indtype == NULL      ||
        indvar == NULL       ||
        complemented == NULL ||
        rhs == NULL          ||
        sense == NULL        ||
        linbeg == NULL       ||
        linind == NULL       ||
        linval == NULL         ) {
      status = CPXERR_NO_MEMORY;
      goto TERMINATE;
   }

   for (i = 0; i < nfoods; ++i) {
      indtype[i] = CPX_INDICATOR_IFANDONLYIF;
      indvar[i] = nbefore + i;
      complemented[i] = 1;
      rhs[i] = 0.0;
      sense[i] = 'L';
      linbeg[i] = i;
      linind[i] = i;
      linval[i] = 1.0;
   }

   /* Add indicator constraints that force the binary variables to 1 if
    * a food is purchased/used. */
   status = CPXXaddindconstraints (env, lp, nfoods, indtype, indvar,
                                   complemented, nfoods, rhs, sense,
                                   linbeg, linind, linval, NULL);
   if ( status )  goto TERMINATE;

   /* Create a second objective. By default, we always have one
    * objective. */
   status = CPXXsetnumobjs (env, lp, 2);
   if ( status )  goto TERMINATE;

   /* Retrieve the current objective (i.e., for the first objective). */
   status = CPXXgetobj (env, lp, linval, 0, nfoods - 1);
   if ( status )  goto TERMINATE;

   /* Adjust priorities such that we optimize the first objective
    * first (i.e., give it a higher priority). Also allow a small
    * degradation in the first objective. */
   status = CPXXmultiobjsetobj (env, lp, 0, nfoods, linind, linval,
                                CPX_NO_OFFSET_CHANGE,
                                CPX_NO_WEIGHT_CHANGE,
                                2,    /* priority */
                                0.5,  /* abstol */
                                CPX_NO_RELTOL_CHANGE,
                                NULL);
   if ( status )  goto TERMINATE;

   for (i = 0; i < nfoods; ++i)
      linval[i] = 1.0;

   /* Set the objective function for the second objective to maximize the
    * sum of the binary variables. Use a negative weight to maximize the
    * second objective and give it a lower priority. The objective senses
    * of all objective functions must match. Hence, we have to formulate
    * max(sum) as min(-sum). */
   status = CPXXmultiobjsetobj (env, lp, 1, nfoods, indvar, linval,
                                CPX_NO_OFFSET_CHANGE,
                                -1.0, /* weight */
                                1,    /* priority */
                                CPX_NO_ABSTOL_CHANGE,
                                CPX_NO_RELTOL_CHANGE,
                                "number of foods");
   if ( status )  goto TERMINATE;

 TERMINATE:

   free_and_null ((char **)&lb);
   free_and_null ((char **)&ub);
   free_and_null ((char **)&xctype);
   free_and_null ((char **)&indtype);
   free_and_null ((char **)&indvar);
   free_and_null ((char **)&complemented);
   free_and_null ((char **)&rhs);
   free_and_null ((char **)&sense);
   free_and_null ((char **)&linbeg);
   free_and_null ((char **)&linind);
   free_and_null ((char **)&linval);

   return (status);

} /* END usemultiobj */


/* Print multi-objective solution information. */
static void
print_multiobj_info (CPXENVptr env,
                     CPXLPptr lp,
                     int subprob,
                     MULTIOBJINFOptr info)
{
   int status = 0;
   MULTIOBJVAL val;

   switch (info->type) {
   case INT_TYPE:
      status = CPXXmultiobjgetintinfo (env, lp, subprob, &val.i, info->what);
      break;
   case CPXCNT_TYPE:
      status = CPXXmultiobjgetcntinfo (env, lp, subprob, &val.l, info->what);
      break;
   case DOUBLE_TYPE:
      status = CPXXmultiobjgetdblinfo (env, lp, subprob, &val.d, info->what);
      break;
   default:
      abort (); /* We should never get here. */
   }

   if ( status )
      printf ("    ---\n");
   else {
      switch (info->type) {
      case INT_TYPE:
         printf ("    %s: %d\n", info->name, val.i);
         break;
      case CPXCNT_TYPE:
         // FIXME: see union multiobjval
         printf ("    %s: %lld\n", info->name, val.l);
         break;
      case DOUBLE_TYPE:
         printf ("    %s: %f\n", info->name, val.d);
         break;
      default:
         abort (); /* We should never get here. */
      }
   }
}


/* Print multi-objective solution statistics. */
static int
printsolstats (CPXENVptr env, CPXLPptr lp)
{
   int status = 0;
   const CPXDIM num = CPXXmultiobjgetnumsolves (env, lp);
   CPXDIM i;

   for (i = 0; i < num; ++i) {
      CPXDIM prio;
      unsigned int const nstats = sizeof (multiobjstats) / sizeof (multiobjstats[0]);
      unsigned int j;

      status = CPXXmultiobjgetdiminfo (env, lp, i, &prio,
                                       CPX_MULTIOBJ_PRIORITY);
      if ( status )  goto TERMINATE;

      printf ("subproblem %d [priority %d]:\n", i, prio);

      for (j = 0; j < nstats; ++j)
         print_multiobj_info (env, lp, i, &multiobjstats[j]);
   }

 TERMINATE:

   return (status);

} /* END printsolstats */

