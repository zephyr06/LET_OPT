#!/usr/bin/python
# ---------------------------------------------------------------------------
# File: diet.py
# Version 22.1.0
# ---------------------------------------------------------------------------
# Licensed Materials - Property of IBM
# 5725-A06 5725-A29 5724-Y48 5724-Y49 5724-Y54 5724-Y55 5655-Y21
# Copyright IBM Corporation 2009, 2022. All Rights Reserved.
#
# US Government Users Restricted Rights - Use, duplication or
# disclosure restricted by GSA ADP Schedule Contract with
# IBM Corp.
# ---------------------------------------------------------------------------
"""Reads data for a dietary problem, builds the model, and solves it.

Input data:
foodmin[j]          minimum amount of food j to use
foodmax[j]          maximum amount of food j to use
cost[j]             cost for one unit of food j
nutrmin[i]          minimum amount of nutrient i
nutrmax[i]          maximum amount of nutrient i
nutrPer[i][j]       nutrition amount of nutrient i in food j

Modeling variables:
buy[j]              amount of food j to purchase

Objective:
minimize sum(j) buy[j] * cost[j]

Constraints:
forall foods i: nutrmin[i] <= sum(j) buy[j] * nutrper[i][j] <= nutrmax[j]

Options:
- build the model by column, rather than by row
- restrict to selecting integral food quantities
- create a multi-objective model

See the usage message for more details.
"""
import sys

import cplex
from cplex.exceptions import CplexSolverError
from inputdata import read_dat_file


def usage(name):
    """Prints a usage statement."""
    msg = """\
Usage: {0} [options...]
   By default, the problem will be generated by rows.

   Supported options are:
   -r    generate problem by row
   -c    generate problem by column
   -i    restrict to integral food quantities (i.e., convert to a MIP)
   -m    create a multi-objective problem where, in addition to
         minimizing cost, the number of unique foods selected is
         maximized (can be combined with -i)
"""
    print(msg.format(name))
    sys.exit(2)


class ProbData():
    """A class to store problem data."""

    def __init__(self, filename):

        # Read in the data from diet.dat.
        (self.food_cost, self.food_min, self.food_max, self.nutr_min,
         self.nutr_max, self.nutr_per) = read_dat_file(filename)

        # Check data consistency.
        if (len(self.food_cost) != len(self.food_min) or
                len(self.food_cost) != len(self.food_max) or
                len(self.nutr_min) != len(self.nutr_max) or
                len(self.nutr_min) != len(self.nutr_per)):
            print("ERROR: Data file '%s' contains inconsistent data\n" %
                  filename)
            raise Exception("data file error")

        for np in self.nutr_per:
            if len(self.food_cost) != len(np):
                print("ERROR: Data file '%s' contains inconsistent data\n" %
                      filename)
                raise Exception("data file error")


def use_integral_variables(prob, varind):
    """Require that foods are purchased/used in integral quantities.

    This will convert the model into a MIP.
    """
    prob.variables.set_types(
        [(ind, prob.variables.type.integer)
         for ind in varind])


def add_second_objective(prob, varind):
    """Add another objective to maximize the number of foods selected.

    This should improve the variety in the diet.
    """
    nvars = len(varind)

    # Create binary variables for each food.
    binvars = list(prob.variables.add(
        lb=[0.0] * nvars,
        ub=[1.0] * nvars,
        types=['B'] * nvars,
        names=['b' + str(j) for j in range(nvars)]))

    # Add indicator constraints that force the binary variables to 1 if
    # a food is purchased/used.
    indvars = list(prob.indicator_constraints.add_batch(
        lin_expr=[[[ind], [1.0]] for ind in varind],
        sense='L' * nvars,
        rhs=[0.0] * nvars,
        indvar=binvars,
        complemented=[1] * nvars,
        name=['i' + str(j) for j in range(nvars)],
        indtype=[prob.indicator_constraints.type_.iff] * nvars))

    # Create a second objective. By default, we always have one
    # objective.
    prob.multiobj.set_num(2)

    # Set the objective name of the second objective (0-indexed).
    prob.multiobj.set_name(1, "number of foods")

    # Set the objective function for the second objective (0-indexed) to
    # maximize the sum of the binary variables.
    prob.multiobj.set_linear(1, [(ind, 1.0) for ind in binvars])

    # Use a negative weight to maximize the second objective. The
    # objective senses of all objective functions must match. Hence, we
    # have to formulate max(sum) as min(-sum).
    prob.multiobj.set_weight(1, -1.0)

    # Adjust priorities, we want to optimize the first objective
    # first so we give it a higher priority.
    prob.multiobj.set_priority(0, 2)
    prob.multiobj.set_priority(1, 1)

    # Allow some small degradation in the first objective.
    prob.multiobj.set_abstol(0, 0.5)


def populate_by_row(prob, data):
    """Generate the problem by row.

    Returns the indices of the variables created.
    """
    nfoods = len(data.food_cost)
    nnutrients = len(data.nutr_min)

    # We want to minimize costs.
    prob.objective.set_sense(prob.objective.sense.minimize)

    # Set the objective name.
    prob.objective.set_name("cost")

    # Add variables to decide how much of each type of food to buy.
    varnames = ["x" + str(j) for j in range(nfoods)]
    varind = list(prob.variables.add(obj=data.food_cost,
                                     lb=data.food_min,
                                     ub=data.food_max,
                                     names=varnames))

    # Add constraints to specify limits for each of the nutrients. Notice
    # that we utilize ranged constraints here.
    rownames = ["r" + str(j) for j in range(nnutrients)]
    prob.linear_constraints.add(
        lin_expr=[[varind, data.nutr_per[n]] for n in range(nnutrients)],
        senses=["R"] * nnutrients,
        rhs=[data.nutr_min[n] for n in range(nnutrients)],
        range_values=[data.nutr_max[n] - data.nutr_min[n]
                      for n in range(nnutrients)],
        names=rownames)

    return varind


def populate_by_column(prob, data):
    """Generate the problem by column.

    Returns the indices of the variables created.
    """
    nfoods = len(data.food_cost)
    nnutrients = len(data.nutr_min)

    # We want to minimize costs.
    prob.objective.set_sense(prob.objective.sense.minimize)

    # Set the objective name.
    prob.objective.set_name("cost")

    # Create empty constraints to be filled later. Notice that we utilize
    # ranged constraints here.
    rownames = ["r" + str(n) for n in range(nnutrients)]
    rowind = list(prob.linear_constraints.add(
        senses=["R" * nnutrients],
        rhs=data.nutr_min,
        range_values=[data.nutr_max[n] - data.nutr_min[n]
                      for n in range(nnutrients)],
        names=rownames))

    # Create columns and fill in the constraint data.
    varnames = ["x" + str(j) for j in range(nfoods)]
    varind = list(prob.variables.add(
        obj=data.food_cost,
        lb=data.food_min,
        ub=data.food_max,
        columns=[[rowind, [data.nutr_per[n][j]
                           for n in range(nnutrients)]]
                 for j in range(nfoods)],
        names=varnames))

    return varind


def print_multiobj_info(prob, subprob, info, what):
    """Print multi-objective solution info."""
    try:
        # Temporarily turn off the error stream to prevent expected
        # errors from being shown in the output.
        prob.set_error_stream(None)
        val = str(prob.solution.multiobj.get_info(subprob, what))
    except CplexSolverError:
        val = "---"
    finally:
        # Restore the error stream.
        prob.set_error_stream(sys.stderr)
    print("    {0}: {1}".format(info[what], val))


def print_solution_stats(prob):
    """Print multi-objective solution statistics."""
    num = prob.solution.multiobj.get_num_solves()
    float_info = prob.solution.multiobj.float_info
    int_info = prob.solution.multiobj.int_info
    long_info = prob.solution.multiobj.long_info
    for i in range(num):
        prio = prob.solution.multiobj.get_info(i, int_info.priority)
        print("subproblem {0} [priority {1}]:".format(i, prio))
        for info, what in ((int_info, int_info.error),
                           (int_info, int_info.status),
                           (float_info, float_info.time),
                           (float_info, float_info.dettime),
                           (long_info, long_info.num_iterations),
                           (float_info, float_info.objective),
                           (float_info, float_info.best_objective),
                           (long_info, long_info.num_nodes),
                           (long_info, long_info.num_nodes_left)):
            print_multiobj_info(prob, i, info, what)


def diet(filename, bycolumn=False, int_vars=False, multiobj=False):
    """Mimimize the cost of a diet subject to nutritional constraints.

    If bycolumn is True, then generate the problem by row. Otherwise,
    generate by column.

    If int_vars is True, the decision variables will be restricted to
    integral values. That is, the foods that are purchased/used will be
    required to be integral quantities. This will convert the model into
    a MIP.

    If multiobj is True, a second objective will be added to the problem
    that will maximize the number of unique foods that are selected.
    """
    # Read the data.
    data = ProbData(filename)

    # Create CPLEX object.
    prob = cplex.Cplex()

    # Populate the problem by row or column.
    if bycolumn:
        varind = populate_by_column(prob, data)
    else:
        varind = populate_by_row(prob, data)

    # Restrict the decision variables to take integral values.
    if int_vars:
        use_integral_variables(prob, varind)

    # Create a second objective.
    if multiobj:
        add_second_objective(prob, varind)

    # Write the model to LP format.
    prob.write("diet.py.lp")

    # Solve the problem.
    if multiobj:
        # Set multi-objective display level to "detailed".
        prob.parameters.multiobjective.display.set(
            prob.parameters.multiobjective.display.values.detailed)

        # Purely for demonstrative purposes, set global and local limits
        # using parameter sets.

        # First, set the global deterministic time limit.
        prob.parameters.dettimelimit.set(60000)

        # Second, create a parameter set for each priority.
        ps1 = prob.create_parameter_set()
        ps2 = prob.create_parameter_set()

        # Set the local deterministic time limits. Optimization will stop
        # whenever either the global or local limit is exceeded.
        ps1.add(prob.parameters.dettimelimit, 50000)
        ps2.add(prob.parameters.dettimelimit, 25000)

        # Optimize the multi-objective problem and apply the parameter
        # sets that were created above. The parameter sets are used
        # one-by-one by each optimization.
        prob.solve([ps1, ps2])
    else:
        prob.solve()

    numrows = prob.linear_constraints.get_num()
    numcols = prob.variables.get_num()

    solution = prob.solution

    # Print the solution status.
    print()
    print("Solution status = {0}: {1}".format(
        solution.get_status(),
        solution.get_status_string()))

    # Print the objective value(s).
    if multiobj:
        for ind in range(prob.multiobj.get_num()):
            print("Objective value {0} ({1}) = {2}".format(
                ind,
                prob.multiobj.get_names(ind),
                solution.multiobj.get_objective_value(ind)))
        print()

        print_solution_stats(prob)
    else:
        print("Objective value = ", solution.get_objective_value())
    print()

    # Print the solution values.
    x = solution.get_values(varind)
    for j, val in enumerate(x):
        print("Buy %d = %17.10g" % (j, val))


def main(args):
    """Checks command line arguments and calls the diet function."""
    filename = "../../data/diet.dat"
    bycolumn = False
    int_vars = False
    multiobj = False
    for arg in args[1:]:
        if arg.startswith("-"):
            if arg == "-r":
                bycolumn = False
            elif arg == "-c":
                bycolumn = True
            elif arg == "-i":
                int_vars = True
            elif arg == "-m":
                multiobj = True
            else:
                print("Unknown argument {0}".format(arg))
                usage(args[0])
        else:
            filename = arg
    diet(filename, bycolumn, int_vars, multiobj)


if __name__ == "__main__":
    main(sys.argv)
